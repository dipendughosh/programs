<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Bottom-Up Parsing</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<B><I><FONT FACE="Lucida Sans" SIZE=5 COLOR="#ff0000"><P ALIGN="CENTER">Bottom-Up Parsing</P>
</B></I></FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">We shall now turn from top-down or predictive parsing to the reverse. Instead of predicting what is to come and verifying it from the input we shall use a bottom-up approach. This means that rather than beginning with the starting symbol and generating an input string, we shall examine the string and attempt to work our way back to the starting symbol. In other words, we shall reconstruct the parse. We will process the input and decide how it was generated using our parser stack as a notebook. Let us begin by examining a string generated by the grammar:</P><DIR>
<DIR>
<DIR>
<DIR>
<DIR>

<P>A <FONT FACE="Symbol">&#174;</FONT>
 aB<BR>
B <FONT FACE="Symbol">&#174;</FONT>
 Ab<BR>
B <FONT FACE="Symbol">&#174;</FONT>
 b </P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>

<P ALIGN="JUSTIFY">The following chart provides an intuitive overview of this new approach to parsing. Here the string aabb is parsed in a bottom-up manner. We shall discuss the steps after presenting the chart.</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image118.gif" WIDTH=419 HEIGHT=222></P>
<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">In step 1 we moved the first input symbol (a) into the examination area and guessed that we might be working on A <FONT FACE="Symbol">&#174;</FONT>
 aB. But, since we had not seen a B we put off making any decisions and pushed the a onto the stack to save it for awhile. In step 2 we did the same. In step three we encountered a b. We knew that it could come from applying the production B <FONT FACE="Symbol">&#174;</FONT>
 b. So we substituted a B for the b. (Remember that we are working backwards.) In step 4 we looked at the stack and sure enough discovered an a. This meant that we could surely apply A <FONT FACE="Symbol">&#174;</FONT>
 aB, and so we did. (We moved the new A in to be examined after getting rid of the B which was there as well as the a on the stack since we used them to make the new A.) In step 5 we looked at the stack and the examination area, could not decide what was going on (except something such as B <FONT FACE="Symbol">&#174;</FONT>
 Ab possibly), so we just put the A onto the stack. Then in step 6 we looked at the b in the examination area and the A on the stack and used them both to make a B via the production B <FONT FACE="Symbol">&#174;</FONT>
 Ab. This B entered the examination area. Looking at this B and the stacked a in step 7 we applied A <FONT FACE="Symbol">&#174;</FONT>
 aB to them and placed an A in the examination area. Since nothing was left to do in step 8 and we were examining our starting symbol we accepted.</P>
<P ALIGN="JUSTIFY">See what happened? We looked at our input string and whenever we could figure out how a symbol was generated, we applied the production that did it. We in essence worked our way <I>up</I> the derivation tree. And, we used the stack to save parts of the tree to our left that we needed to tie in later. Since our grammar was unambiguous and deterministic, we were able of do it.</P>
<P ALIGN="JUSTIFY">Now let us do it all over with some new terminology and some mixing up of the above columns. When we push an input symbol into the stack we shall call it a <I>shift</I>. And when we apply a production we shall call it a <I>reduce</I> operation. We shall <I>shift</I> our guesses onto the stack with input symbols. For example, if we see an a and guess that we're seeing the results of applying the production A <FONT FACE="Symbol">&#174;</FONT>
 aB, we shift the pair (a, aB) onto the stack. After we <I>reduce</I>, we shall place a guess pair on the stack with the nonterminal we just produced. Here we go.</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image119.gif" WIDTH=425 HEIGHT=221></P>
<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">Our new parsing technique involves keeping notes on past input on the stack. For instance, in step 5 we have an a (which might be part of an aB) at the bottom of our stack, and an A (which we hope shall be part of an Ab) on top of the stack. We then use these notes to try to work backwards to the starting symbol. This is what happens when we do reduce operations. This is the standard bottom-up approach we have always seen in computer science. Our general method is to do a rightmost derivation except that we do it backwards! Neat. What we did at each step was to examine the stack and see if we could do a reduction by applying a production to the top elements of the stack. If so, then we replaced the right hand side symbols (which were at the top of the stack) with the left-hand side nonterminal.</P>
<P ALIGN="JUSTIFY">After doing a reduction we put the new nonterminal on the stack along with a guess of what was being built. We also did this when we shifted a terminal onto the stack. Let us examine these guesses. We tried to make them as accurate as possible by looking at the stack before pushing the (symbol, guess) pair. We should also note that the pair (a,aB) means that we have placed the a on the stack and think that maybe a B will come along. On the other hand, the pair (b,Ab) indicates that the top two symbols on the stack are A and b, and, we have seen the entire right hand side of a production. Thus we always keep track of what is in the stack.</P>
<P ALIGN="JUSTIFY">Now for another enhancement. We shall get rid of some duplication. Instead of placing (a, aB) on the stack we shall just put a|B on it. This means that we have seen the part of aB which comes before the vertical line - the symbol a. Putting aB| on the stack means that we have a and B as our top two stack symbols. Here is the same computation with our new stack symbols.</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image120.gif" WIDTH=425 HEIGHT=221></P>
<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">Let's pause a bit and examine these things we are placing on the stack. They are often called <I>states</I> and do indicate the state of the input string we have read and partially parsed. States are made up of <I>items</I> that are just productions with an indicator that tells us how far on the right hand side we have progressed. The set of items for the previous grammar is: </P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=235>
<TR><TD WIDTH="35%" VALIGN="TOP">
<P ALIGN="JUSTIFY"><FONT FACE="Arial">A </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> |aB</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">B </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> |Ab</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">B </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> |b</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">A </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> a|B</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">B </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> A|b</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">B </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> b|</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">A </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> aB|</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">B </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> Ab|</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">Recall what an item means. A <FONT FACE="Symbol">&#174;</FONT>
 a|B means that we have seen an a and hope to see a B and apply the production. Traditionally we also invent a new starting symbol and add a production where it goes to the old starting symbol. In this case this means adding the items:</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=226>
<TR><TD WIDTH="35%" VALIGN="TOP">
<P><FONT FACE="Arial">S<SUB>0</SUB> </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> |A</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial"><P>S<SUB>0</SUB> </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Arial"> A|</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">to our collection of items.</P>
<P ALIGN="JUSTIFY">There are lots and lots of items in a grammar. Some are almost the same. Now it is time to group equivalent items together. We take a closure of an item and get all of the equivalent ones. These <I>closures</I> shall form the stack symbols (or states) of our parser. These are computed according to the following procedure.</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image121.gif" WIDTH=441 HEIGHT=174></P>
<B><FONT FACE="Lucida Sans"><P ALIGN="CENTER">Figure 5 - Closure Computation for Items</P>
</B></FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">We should compute a few closures for the items in our grammar. The only time we get past the first step above is when the vertical bar is to the left of a nonterminal. Such as in B <FONT FACE="Symbol">&#174;</FONT>
 |Ab. Let's do that one. We place B <FONT FACE="Symbol">&#174;</FONT>
 |Ab in CLOSURE(B <FONT FACE="Symbol">&#174;</FONT>
 |Ab) first. Then we look at all A <FONT FACE="Symbol">&#174;</FONT>
 a productions and put A <FONT FACE="Symbol">&#174;</FONT>
 |a in CLOSURE(B <FONT FACE="Symbol">&#174;</FONT>
 |Ab) also. This gives us: </P>
<P ALIGN="CENTER">CLOSURE(B <FONT FACE="Symbol">&#174;</FONT>
 |Ab) = {B <FONT FACE="Symbol">&#174;</FONT>
 |Ab, A <FONT FACE="Symbol">&#174;</FONT>
 |aB}</P>
<P ALIGN="JUSTIFY">Some more closures are:</P>

<DIR>
<DIR>
<DIR>
<DIR>
<P ALIGN="JUSTIFY">CLOSURE(S <FONT FACE="Symbol">&#174;</FONT>
 |A) = {S <FONT FACE="Symbol">&#174;</FONT>
 |A, A <FONT FACE="Symbol">&#174;</FONT>
 |aB}<BR>
CLOSURE(S <FONT FACE="Symbol">&#174;</FONT>
 A|) = {S <FONT FACE="Symbol">&#174;</FONT>
 A|}<BR>
CLOSURE(A <FONT FACE="Symbol">&#174;</FONT>
 a|B) = {A <FONT FACE="Symbol">&#174;</FONT>
 a|B, B <FONT FACE="Symbol">&#174;</FONT>
 |Ab, B <FONT FACE="Symbol">&#174;</FONT>
 |b, A <FONT FACE="Symbol">&#174;</FONT>
 |aB} <BR>
</DIR>
</DIR>
</DIR>
</DIR>

<P ALIGN="JUSTIFY">Thus the closure of an item is a collection of all items which represent the same sequence of things placed upon the stack recently. These items in the set are what we have seen on the input string and processed. The productions represented are all those which might be applied soon. The last closure presented above is particularly interesting since it tells us that we have seen an a and should be about to see a B. Thus either Ab, b, or aB could be arriving shortly. States will built presently by combining closures of items.</P>
<P ALIGN="JUSTIFY">Let's return to our last table where we did a recognition of aabb. Note that in step 2 a|B was on top to the stack and the next input was b. We then placed b| on the stack. Traditionally sets of items called states are placed upon the stack and so the process of putting the next state on the stack is referred to as a <I>GOTO</I>. Thus from step 2 to step 3 in the recognition of aabb we execute:</P>
</FONT><FONT FACE="Arial"><P ALIGN="CENTER">GOTO(a|B, b) = b|.</P>
</FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">In step 3 we reduced with the production B <FONT FACE="Symbol">&#174;</FONT>
 b and got a B. We then placed aB| on the stack. In our new terminology this is:</P>
</FONT><FONT FACE="Arial"><P ALIGN="CENTER">GOTO(a|B, B) = aB|.</P>
</FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">It is time now to precisely define the GOTO operation. For a set of items (or state) Q and symbol x this is:</P>
</FONT><FONT FACE="Arial"><P ALIGN="CENTER">GOTO(Q, x) = {CLOSURE(A <FONT FACE="Symbol">&#174;</FONT>
 a x|b )} for all A <FONT FACE="Symbol">&#174;</FONT>
 a |xb &Icirc; Q </P>
</FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">Check out the operations we 
looked at above and those in the previous acceptance table. Several more examples 
are:</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=517>
<TR>
<TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="RIGHT">
GOTO({S <FONT FACE="Symbol">&#174;</FONT> |A, A <FONT FACE="Symbol">&#174;</FONT> |aB}, A)</FONT></TD>

<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">
= CLOSURE(S <FONT FACE="Symbol">&#174;</FONT>
 A|)<BR>
= {S <FONT FACE="Symbol">&#174;</FONT>
A|}</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="RIGHT">GOTO({S <FONT FACE="Symbol">&#174;</FONT>
 |A, A <FONT FACE="Symbol">&#174;</FONT>
 |aB}, a)</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial"><P ALIGN="JUSTIFY">
= CLOSURE(A <FONT FACE="Symbol">&#174;</FONT>
 a|B)<BR>
= {A <FONT FACE="Symbol">&#174;</FONT>
 a|B, B <FONT FACE="Symbol">&#174;</FONT>
 |Ab, B <FONT FACE="Symbol">&#174;</FONT>
 |b, A <FONT FACE="Symbol">&#174;</FONT>
 |aB}</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">So, all we need do is add a new starting production (</FONT><FONT FACE="Arial">S<SUB>0</SUB> <FONT FACE="Symbol">&#174;</FONT>
 S</FONT><FONT FACE="Lucida Bright">) to a grammar and execute the following state construction algorithm in order to generate all the states we require in order to do parsing.</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image122.gif" WIDTH=366 HEIGHT=247></P>
<B><FONT FACE="Lucida Sans"><P ALIGN="CENTER">Figure 6 - State Construction Algorithm</P>
</B></FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">The seven states determined for 
our example grammar using the above algorithm are:</P>

<DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>
</FONT><FONT FACE="Arial">
Q<SUB>0</SUB> = {S <FONT FACE="Symbol">&#174;</FONT>
 |A, A <FONT FACE="Symbol">&#174;</FONT>
 |aB}<BR>
Q<SUB>1</SUB> = {S <FONT FACE="Symbol">&#174;</FONT>
 A|}<BR>
Q<SUB>2</SUB> = {A <FONT FACE="Symbol">&#174;</FONT>
 a|B, B <FONT FACE="Symbol">&#174;</FONT>
 |Ab, B <FONT FACE="Symbol">&#174;</FONT>
 |b, A <FONT FACE="Symbol">&#174;</FONT>
 |aB}<BR>
Q<SUB>3</SUB> = {A <FONT FACE="Symbol">&#174;</FONT>
 aB|}<BR>
Q<SUB>4</SUB> = {B <FONT FACE="Symbol">&#174;</FONT>
 A|b}<BR>
Q<SUB>5</SUB> = {B <FONT FACE="Symbol">&#174;</FONT>
 b|}<BR>
Q<SUB>6</SUB> = {B <FONT FACE="Symbol">&#174;</FONT>
 Ab|}<BR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">and the relationships formed from the GOTO(Q, x) relationship are: </P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image123.gif" WIDTH=215 HEIGHT=137></P>
<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">Note that not all state-symbol pairs are represented. We do know why there are no states to go to from </FONT><FONT FACE="Arial">Q<SUB>1</SUB>, Q<SUB>3</SUB>, Q<SUB>5</SUB>,</FONT><FONT FACE="Lucida Bright"> and </FONT><FONT FACE="Arial">Q<SUB>6</SUB></FONT><FONT FACE="Lucida Bright"> - right? Because they are states that contain items we shall reduce. After that we shall place another item on the stack as part of the reduction process.</P>
<P ALIGN="JUSTIFY">All that remains is to build a parser that will carry out the sample computation we presented above. It is easy. Here are the rules for building the parser table. (Recall that the stack symbols or states are along the left side while grammar symbols lie across the top.)</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image124.gif" WIDTH=474 HEIGHT=153></P>
<B><FONT FACE="Lucida Sans"><P ALIGN="CENTER">Figure 7 - Parser Table Construction</P>
</B></FONT><FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">That is all there is to it. Quite simple. Another note - we shall attach a GOTO table to the right side of our parser table so that we know what to place on the stack after a reduction. The parser for our sample grammar is provided below. The words <I>shift</I> and <I>reduce</I> have been omitted because they refer always to states and productions respectively and there should be no problem telling which is which. (Aliases for the states have been provided so that the table is readable.)</P>
</FONT><P ALIGN="CENTER"><IMG SRC="Image125.gif" WIDTH=432 HEIGHT=223></P>
<FONT FACE="Lucida Bright"><P ALIGN="JUSTIFY">We know intuitively how these parsers work, but need to specify some things precisely. <I>Shift</I> operations merely push the indicated state on the stack. A <I>reduce</I> operation has two parts. For a reduction of A </FONT><FONT FACE="Symbol">&reg;</FONT><FONT FACE="Lucida Bright"> </FONT><FONT FACE="Symbol">a</FONT><FONT FACE="Lucida Bright"> where the length of </FONT><FONT FACE="Symbol">a</FONT><FONT FACE="Lucida Bright"> is k, first pop k states off the stack. (These are the right hand side symbols for the production.) Then if </FONT><FONT FACE="Arial">Q<SUB>i</SUB></FONT><FONT FACE="Lucida Bright"> is on top of the stack, push GOTO(</FONT><FONT FACE="Arial">Q<SUB>i</SUB> </FONT><FONT FACE="Lucida Bright">,A) onto the stack. So, what we are doing is to examine the stack and push the proper state depending upon what was at the top and what was about to be processed. And last, begin with </FONT><FONT FACE="Arial">Q<SUB>0</SUB></FONT><FONT FACE="Lucida Bright"> on the stack. Try out our last example and note that exactly the same sequence of moves results.</P>
<P ALIGN="JUSTIFY">Now let us label what we have been doing. Since we have been processing the input from left to right and doing rightmost derivations, this is called <I>LR parsing</I>. And the following theorem ties the LR languages into our framework.</P><DIR>
<DIR>

</FONT><B><FONT FACE="Lucida Bright" COLOR="#0000ff"><P ALIGN="JUSTIFY">Theorem. </B><I>The following classes are equivalent.</P><DIR>
<DIR>

<P>a) Deterministic context free languages.</I></FONT><FONT FACE="Lucida Bright"> <BR>
</FONT><I><FONT FACE="Lucida Bright" COLOR="#0000ff">b) LR(1) languages.</I></FONT><FONT FACE="Lucida Bright"> <BR>
</FONT><I><FONT FACE="Lucida Bright" COLOR="#0000ff">c) LR(0) languages with endmarkers.</I></FONT><FONT FACE="Lucida Bright"> <BR>
</FONT><I><FONT FACE="Lucida Bright" COLOR="#0000ff">d) Languages accepted by deterministic pushdown automata.</P></DIR>
</DIR>
</DIR>
</DIR>
</I></FONT></BODY>
</HTML>
